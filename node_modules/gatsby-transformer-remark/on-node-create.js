"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const grayMatter = require(`gray-matter`);

const crypto = require(`crypto`);

const _ = require(`lodash`);

module.exports =
/*#__PURE__*/
function () {
  var _onCreateNode = (0, _asyncToGenerator2.default)(function* ({
    node,
    loadNodeContent,
    actions,
    createNodeId,
    reporter
  }, _ref = {}) {
    let _ref$plugins = _ref.plugins,
        plugins = _ref$plugins === void 0 ? null : _ref$plugins,
        _ref$filter = _ref.filter,
        filter = _ref$filter === void 0 ? () => true : _ref$filter,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? `MarkdownRemark` : _ref$type,
        grayMatterOptions = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["plugins", "filter", "type"]);
    const createNode = actions.createNode,
          createParentChildLink = actions.createParentChildLink; // We only care about markdown content.

    if (node.internal.mediaType !== `text/markdown` && node.internal.mediaType !== `text/x-markdown` || !filter(node)) {
      return {};
    }

    const content = yield loadNodeContent(node);

    try {
      let data = grayMatter(content, grayMatterOptions);

      if (data.data) {
        data.data = _.mapValues(data.data, value => {
          if (_.isDate(value)) {
            return value.toJSON();
          }

          return value;
        });
      }

      let markdownNode = {
        id: createNodeId(`${node.id} >>> ${type}`),
        children: [],
        parent: node.id,
        internal: {
          content: data.content,
          type
        }
      };
      markdownNode.frontmatter = Object.assign({
        title: ``
      }, data.data);
      markdownNode.excerpt = data.excerpt;
      markdownNode.rawMarkdownBody = data.content; // Add path to the markdown file path

      if (node.internal.type === `File`) {
        markdownNode.fileAbsolutePath = node.absolutePath;
      }

      markdownNode.internal.contentDigest = crypto.createHash(`md5`).update(JSON.stringify(markdownNode)).digest(`hex`);
      createNode(markdownNode);
      createParentChildLink({
        parent: node,
        child: markdownNode
      });
      return markdownNode;
    } catch (err) {
      reporter.panicOnBuild(`Error processing Markdown ${node.absolutePath ? `file ${node.absolutePath}` : `in node ${node.id}`}:\n
      ${err.message}`);
      return {}; // eslint
    }
  });

  return function onCreateNode(_x) {
    return _onCreateNode.apply(this, arguments);
  };
}();